lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
H1 = seq(3.42, 3.43, length.out = 100)
critere = sapply(H1, function(h) critereCV(CO2$uptake, h))
(hopt = H1[which.min(critere)])#3.423838
plot(H1, critere, pch = 16, xlab ="h", ylab = "critere", main = "critere en fonction du pas h pour CO2$uptake")# pch= code du symbole de chaque points
points(hopt, min(critere, na.rm = T), pch = 16, col = 2)# ajoute le point de coordonnées (hopt,  min(critere, na.rm = T)) en rouge
text(hopt - 0.003 , min(critere, na.rm = T), labels = paste("hopt"), col = 2)# ajoute du caractère depuis labels à la position (X,Y)=(hopt - 0.001 , min(critere, na.rm = T))
(K=round((45.50-7.70)/hopt))
Grid = seq(7.70, 45.50, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
dens.by.us$f_chap_h
(K=round((45.50-7.70)/hopt))
Grid = seq(0, 45.50, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
# lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
# legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
(K=round((45.50-7.70)/hopt))
Grid = seq(0, 45.50, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
(K=round((45.50-7.70)/hopt))
Grid = seq(0, 60, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
(K=round((45.5-7.7)/hopt))
Grid = seq(7.7, 60, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
(K=round((45.5-7.7)/hopt))
Grid = seq(0, 200, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
(K=round((45.5-7.7)/hopt))
Grid = seq(0, 500, length.out = 80)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
hotp
hopt
1/hopt
(K=round((45.5-7.7)/hopt))
(K=round((45.5-7.7)/hopt))
Grid = seq(7, 46, length.out = K+1)# K+1 valeurs de x / x compris entre 7.7 et 45.5 par pas de hopt=3.4238 car X=CO2$uptake€[7.7;45.5]
dens.by.us = densityGauss(CO2$uptake, h =hopt, Grid=Grid , choise.plot= F)
hist(CO2$uptake, probability = TRUE)#curve(V*dbeta(x, a1, b1) + (1-V)*dbeta(x, a2, b2), add = T, col =2, lwd = 3 )
lines(dens.by.r, col = 'red', lwd = 2)
lines(dens.by.us$Grid, dens.by.us$f_chap_h, col = 'purple', lwd = 2)
legend(x = 0.3, y = 2.5, legend = c("with hopt by us", "with hopt by R"), col = c('purple', 'red'), lty = 1, lwd = 2, bty = "n")
library(shiny)
library(shinyFeedback)
install.packages("shinyFeedback")
library(shiny)
library(shinyFeedback)
ui <- function(){
tagList(
# Attaching the {shinyFeedback} dependencies
useShinyFeedback(),
# Recreating our selectInput + plot from before
selectInput(
"species",
"Choose one or more species",
choices = unique(iris$Species),
multiple = TRUE,
selected = unique(iris$Species)[1]
),
plotOutput("plt")
)
}
server <- function(
input,
output,
session
){
output$plt <- renderPlot({
# If the length of the input is 0
# (i.e. nothing is selected),we show
# a feedback to the user in the form of a text
# If the length > 0, we remove the feedback.
if (length(input$species) == 0){
showFeedbackWarning(
inputId = "species",
text = "Select at least one Species"
)
} else {
hideFeedback("species")
}
# req() allows to stop further code execution
# if the condition is not a truthy.
# Hence if input$species is NULL, the computation
# will be stopped here.
req(input$species)
plot(
iris[ iris$Species %in% input$species, ]
)
})
}
shinyApp(ui, server)
library(shiny)
library(shinyFeedback)
ui <- function(){
tagList(
# Attaching the {shinyFeedback} dependencies
useShinyFeedback(),
# Recreating our selectInput + plot from before
selectInput(
"species",
"Choose one or more species",
choices = unique(iris$Species),
multiple = TRUE,
selected = unique(iris$Species)[1]
),
plotOutput("plt")
)
}
server <- function(
input,
output,
session
){
output$plt <- renderPlot({
# If the length of the input is 0
# (i.e. nothing is selected),we show
# a feedback to the user in the form of a text
# If the length > 0, we remove the feedback.
if (length(input$species) == 0){
showFeedbackWarning(
inputId = "species",
text = "Select at least one Species"
)
} else {
hideFeedback("species")
}
# req() allows to stop further code execution
# if the condition is not a truthy.
# Hence if input$species is NULL, the computation
# will be stopped here.
req(input$species)
plot(
iris[ iris$Species %in% input$species, ]
)
})
}
shinyApp(ui, server)
library(shiny)
library(shinyFeedback)
ui <- function(){
tagList(
# Attaching the {shinyFeedback} dependencies
useShinyFeedback(),
# Recreating our selectInput + plot from before
selectInput(
"species",
"Choose one or more species",
choices = unique(iris$Species),
multiple = TRUE,
selected = unique(iris$Species)[1]
),
plotOutput("plt")
)
}
server <- function(
input,
output,
session
){
output$plt <- renderPlot({
# If the length of the input is 0
# (i.e. nothing is selected),we show
# a feedback to the user in the form of a text
# If the length > 0, we remove the feedback.
if (length(input$species) == 0){
showFeedbackWarning(
inputId = "species",
text = "Select at least one Species"
)
} else {
hideFeedback("species")
}
# req() allows to stop further code execution
# if the condition is not a truthy.
# Hence if input$species is NULL, the computation
# will be stopped here.
req(input$species)
plot(
iris[ iris$Species %in% input$species, ]
)
})
}
shinyApp(ui, server)
library(shiny)
ui <- function(){
# Here, we would define the interface
tagList(
# [...]
)
}
server <- function(
input,
output,
session
){
# We are attempting to connect to the database,
# using a `connect_db()` connection
conn <- attempt::attempt({
connect_db()
})
# if ever this connection failed, we notify the user
# about this failed connection, so that they can know
# what has gone wrong
if (attempt::is_try_error(conn)){
# Notify the user
send_notification("Could not connect")
} else {
# Continue computing if the connection was successful
continue_computing()
}
}
shinyApp(ui, server)
library(shiny)
ui <- function(){
# Here, we would define the interface
tagList(
# [...]
)
}
server <- function(
input,
output,
session
){
# We are attempting to connect to the database,
# using a `connect_db()` connection
conn <- attempt::attempt({
connect_db()
})
# if ever this connection failed, we notify the user
# about this failed connection, so that they can know
# what has gone wrong
if (attempt::is_try_error(conn)){
# Notify the user
send_notification("Could not connect")
} else {
# Continue computing if the connection was successful
continue_computing()
}
}
shinyApp(ui, server)
library(shiny)
library(magrittr)
ui <- function(){
# Generating a UI with one plot
tagList(
plotOutput("plot") %>%
# Adding the `alt` attribute to our plot
tagAppendAttributes(alt = "Plot of iris")
)
}
server <- function(
input,
output,
session
){
# Generating the plot from the server side,
# no modification here
output$plot <- renderPlot({
plot(iris)
})
}
shinyApp(ui, server)
library(shiny)
ui <- function(){
# Here, we would define the interface
tagList(
# [...]
)
}
server <- function(
input,
output,
session
){
# We are attempting to connect to the database,
# using a `connect_db()` connection
conn <- attempt::attempt({
connect_db()
})
# if ever this connection failed, we notify the user
# about this failed connection, so that they can know
# what has gone wrong
if (attempt::is_try_error(conn)){
# Notify the user
send_notification("Could not connect")
} else {
# Continue computing if the connection was successful
continue_computing()
}
}
shinyApp(ui, server)
library(shiny)
library(shinyFeedback)
ui <- function(){
tagList(
# Attaching the {shinyFeedback} dependencies
useShinyFeedback(),
# Recreating our selectInput + plot from before
selectInput(
"species",
"Choose one or more species",
choices = unique(iris$Species),
multiple = TRUE,
selected = unique(iris$Species)[1]
),
plotOutput("plt")
)
}
server <- function(
input,
output,
session
){
output$plt <- renderPlot({
# If the length of the input is 0
# (i.e. nothing is selected),we show
# a feedback to the user in the form of a text
# If the length > 0, we remove the feedback.
if (length(input$species) == 0){
showFeedbackWarning(
inputId = "species",
text = "Select at least one Species"
)
} else {
hideFeedback("species")
}
# req() allows to stop further code execution
# if the condition is not a truthy.
# Hence if input$species is NULL, the computation
# will be stopped here.
req(input$species)
plot(
iris[ iris$Species %in% input$species, ]
)
})
}
shinyApp(ui, server)
library(dplyr)
library(readr)
View(df)
df
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
#setwd("~/NewOrdi/API_Recueil/APIname/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/archive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
#setwd("~/NewOrdi/API_Recueil/APIname/data-row/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/archive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
View(df)
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
#setwd("~/NewOrdi/API_Recueil/APIname/data-row/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-row/archive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
View(df)
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
#setwd("~/NewOrdi/API_Recueil/APIname/data-raw/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-raw/archive') %>%
lapply(read_csv) %>%
bind_rows
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-raw') %>%
lapply(read_csv) %>%
bind_rows
setwd("~/NewOrdi/API_Recueil/APIname/data-raw/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-rawarchive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
setwd("~/NewOrdi/API_Recueil/APIname/data-raw/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-rawarchive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
library(dplyr)
library(readr)
#import and merge all three CSV files into one data frame
setwd("~/NewOrdi/API_Recueil/APIname/data-raw/archive")
df <- list.files(path='~/NewOrdi/API_Recueil/APIname/data-raw/archive') %>%
lapply(read_csv) %>%
bind_rows
View(df)
usethis::use_data(df, overwrite = TRUE)
df
summary(df)
names(df)
names(df) ; summary(df)
names(df) ; summary(df) ;stdr(df)
names(df) ; summary(df)
names(df) ; summary(df)$mode
names(df) ; summary(df)
# nb de morts par saison
#plot
df %>% select("Episode", "episode")
# nb de morts par saison
#plot
df
epi1=read.csv(~/NewOrdi/API_Recueil/APIname/data-raw/archive/breaking_bad_episodes.csv, header = TRUE, sep = "," ,dec = ".")
epi1=read.csv(breaking_bad_episodes.csv, header = TRUE, sep = "," ,dec = ".")
#import and merge all three CSV files into one data frame
setwd("~/NewOrdi/API_Recueil/APIname/data-raw/archive")
epi1=read.csv(breaking_bad_episodes.csv, header = TRUE, sep = "," ,dec = ".")
epi1=read.csv("~/NewOrdi/API_Recueil/APIname/data-raw/archive/breaking_bad_episodes.csv", header = TRUE, sep = "," ,dec = ".")
epi1
epi2=read.csv("~/NewOrdi/API_Recueil/APIname/data-raw/archive/episodes.csv", header = TRUE, sep = "," )
epi
epi2
death=read.csv("~/NewOrdi/API_Recueil/APIname/data-raw/archive/deaths.csv", header = TRUE, sep = "," )
deaths
death
vote=read.csv("~/NewOrdi/API_Recueil/APIname/data-raw/archive/breaking_bad_imdb.csv", header = TRUE, sep = "," )
vote
death
epi1_cols= names(epi1)
epi1_cols[epi1_cols %in% names(epi2)]
char=read.csv("~/NewOrdi/API_Recueil/APIname/data-raw/archive/characters.csv", header = TRUE, sep = "," )
char
stdr(epi1)
str(epi1)
str(death)
deaths
death
# nb de morts par saison
# le nombre de personnages morts dans l’ensemble de la série:
nb_deaths_total_serie=sum(death$number_of_deaths)
# nb de morts par saison
# le nombre de personnages morts dans l’ensemble de la série:
(nb_deaths_total_serie=sum(death$number_of_deaths))
library(tidyverse)
#nb le nombre de personnages morts par saison:
death %>% group_by(season) %>% summarise( nb_deaths_per_season=sum(number_of_deaths))
#nb le nombre de personnages morts par saison:
death %>% group_by(season) %>% summarise( nb_deaths_per_season=sum(number_of_deaths)) %>% arrange(nb_deaths_per_season)
#les 5 plus grands meurtriers de la série:
death %>% group_by(responsible) %>% summarise(nb_deaths_per_responsible=sum(number_of_deaths)) %>% arrange(nb_deaths_per_responsible)
death %>% group_by(responsible) %>% summarise(nb_deaths_per_responsible=sum(number_of_deaths)) %>% arrange(desc(nb_deaths_per_responsible))
char
vote
vote
epi2
epi1
epi1
#nb de vu aux usa/episodes et par saison:
epi1 %>% select("episode_num_in_season", "us_viewers ")
#nb de vu aux usa/episodes et par saison:
epi1 %>% select(episode_num_in_season, us_viewers)
epi1 %>% group_by(season) %>% summarise(nb_us_viewers_per_season= sum(us_viewers))
epi1 %>% group_by(season) %>% summarise(nb_us_viewers_per_season= sum(us_viewers)) %>% arrange(desc(nb_us_viewers_per_season))
#nb de vu aux usa/episodes et par saison:
epi1 %>% select(episode_num_in_season, us_viewers, written_by)
#nb de vus aux usa/episodes:
epi1 %>% select(episode_num_in_season, season , us_viewers, written_by) %>% arrange(desc(us_viewers))
epi1
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epis_per_writter_per_seas= n(episode_num_overall)
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epis_per_writter_per_seas= n(episode_num_overall)
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% tally()
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% tally() %>% arrange(season)
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epis_per_writter_per_seas= n(episode_num_overall))
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epis_per_writter_per_seas= count(episode_num_overall))
epi1 %>% group_by(written_by, season)
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% arrange(written_by)
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epi_per_writter_&_seas=n())
#nb d'episodes par ecrivain(e):
epi1 %>% group_by(written_by, season) %>% summarise(nb_epi_per_writter_seas=n())
